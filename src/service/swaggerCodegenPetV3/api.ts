/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Swagger Petstore - OpenAPI 3.0
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach! You can now help us improve the API whether it's by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 *
 * OpenAPI spec version: 1.0.6
 * Contact: apiteam@swagger.io
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'https://petstore3.swagger.io/api/v3'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   *
   * @type {string}
   * @memberof Address
   */
  street?: string
  /**
   *
   * @type {string}
   * @memberof Address
   */
  city?: string
  /**
   *
   * @type {string}
   * @memberof Address
   */
  state?: string
  /**
   *
   * @type {string}
   * @memberof Address
   */
  zip?: string
}
/**
 *
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
  /**
   *
   * @type {number}
   * @memberof ApiResponse
   */
  code?: number
  /**
   *
   * @type {string}
   * @memberof ApiResponse
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof ApiResponse
   */
  message?: string
}
/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {number}
   * @memberof Category
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Category
   */
  name?: string
}
/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
  /**
   *
   * @type {number}
   * @memberof Customer
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  username?: string
  /**
   *
   * @type {Array<Address>}
   * @memberof Customer
   */
  address?: Array<Address>
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
  /**
   *
   * @type {number}
   * @memberof Order
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof Order
   */
  petId?: number
  /**
   *
   * @type {number}
   * @memberof Order
   */
  quantity?: number
  /**
   *
   * @type {Date}
   * @memberof Order
   */
  shipDate?: Date
  /**
   * Order Status
   * @type {string}
   * @memberof Order
   */
  status?: Order.StatusEnum
  /**
   *
   * @type {boolean}
   * @memberof Order
   */
  complete?: boolean
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Placed = <any>'placed',
    Approved = <any>'approved',
    Delivered = <any>'delivered',
  }
}
/**
 *
 * @export
 * @interface Pet
 */
export interface Pet {
  /**
   *
   * @type {number}
   * @memberof Pet
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Pet
   */
  name: string
  /**
   *
   * @type {Category}
   * @memberof Pet
   */
  category?: Category
  /**
   *
   * @type {Array<string>}
   * @memberof Pet
   */
  photoUrls: Array<string>
  /**
   *
   * @type {Array<Tag>}
   * @memberof Pet
   */
  tags?: Array<Tag>
  /**
   * pet status in the store
   * @type {string}
   * @memberof Pet
   */
  status?: Pet.StatusEnum
}

/**
 * @export
 * @namespace Pet
 */
export namespace Pet {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Available = <any>'available',
    Pending = <any>'pending',
    Sold = <any>'sold',
  }
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
  /**
   *
   * @type {number}
   * @memberof Tag
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  name?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string
  /**
   * User Status
   * @type {number}
   * @memberof User
   */
  userStatus?: number
}
/**
 * PetApi - fetch parameter creator
 * @export
 */
export const PetApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add a new pet to the store
     * @summary Add a new pet to the store
     * @param {Pet} body Create a new pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'category' is not null or undefined
      if (category === null || category === undefined) {
        throw new RequiredError(
          'category',
          'Required parameter category was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'photoUrls' is not null or undefined
      if (photoUrls === null || photoUrls === undefined) {
        throw new RequiredError(
          'photoUrls',
          'Required parameter photoUrls was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'tags' is not null or undefined
      if (tags === null || tags === undefined) {
        throw new RequiredError(
          'tags',
          'Required parameter tags was null or undefined when calling addPet.',
        )
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          'status',
          'Required parameter status was null or undefined when calling addPet.',
        )
      }
      const localVarPath = `/pet`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (id !== undefined) {
        localVarFormParams.set('id', id as any)
      }

      if (name !== undefined) {
        localVarFormParams.set('name', name as any)
      }

      if (category !== undefined) {
        localVarFormParams.set('category', category as any)
      }

      if (photoUrls) {
        photoUrls.forEach((element) => {
          localVarFormParams.append('photoUrls', element as any)
        })
      }

      if (tags) {
        tags.forEach((element) => {
          localVarFormParams.append('tags', element as any)
        })
      }

      if (status !== undefined) {
        localVarFormParams.set('status', status as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Pet' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePet(petId: number, apiKey?: string, options: any = {}): FetchArgs {
      // verify required parameter 'petId' is not null or undefined
      if (petId === null || petId === undefined) {
        throw new RequiredError(
          'petId',
          'Required parameter petId was null or undefined when calling deletePet.',
        )
      }
      const localVarPath = `/pet/{petId}`.replace(
        `{${'petId'}}`,
        encodeURIComponent(String(petId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (apiKey !== undefined && apiKey !== null) {
        localVarHeaderParameter['api_key'] = String(apiKey)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {string} [status] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByStatus(status?: string, options: any = {}): FetchArgs {
      const localVarPath = `/pet/findByStatus`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} [tags] Tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByTags(tags?: Array<string>, options: any = {}): FetchArgs {
      const localVarPath = `/pet/findByTags`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (tags) {
        localVarQueryParameter['tags'] = tags
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPetById(petId: number, options: any = {}): FetchArgs {
      // verify required parameter 'petId' is not null or undefined
      if (petId === null || petId === undefined) {
        throw new RequiredError(
          'petId',
          'Required parameter petId was null or undefined when calling getPetById.',
        )
      }
      const localVarPath = `/pet/{petId}`.replace(
        `{${'petId'}}`,
        encodeURIComponent(String(petId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication api_key required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('api_key')
            : configuration.apiKey
        localVarHeaderParameter['api_key'] = localVarApiKeyValue
      }

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing pet by Id
     * @summary Update an existing pet
     * @param {Pet} body Update an existent pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'category' is not null or undefined
      if (category === null || category === undefined) {
        throw new RequiredError(
          'category',
          'Required parameter category was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'photoUrls' is not null or undefined
      if (photoUrls === null || photoUrls === undefined) {
        throw new RequiredError(
          'photoUrls',
          'Required parameter photoUrls was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'tags' is not null or undefined
      if (tags === null || tags === undefined) {
        throw new RequiredError(
          'tags',
          'Required parameter tags was null or undefined when calling updatePet.',
        )
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          'status',
          'Required parameter status was null or undefined when calling updatePet.',
        )
      }
      const localVarPath = `/pet`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (id !== undefined) {
        localVarFormParams.set('id', id as any)
      }

      if (name !== undefined) {
        localVarFormParams.set('name', name as any)
      }

      if (category !== undefined) {
        localVarFormParams.set('category', category as any)
      }

      if (photoUrls) {
        photoUrls.forEach((element) => {
          localVarFormParams.append('photoUrls', element as any)
        })
      }

      if (tags) {
        tags.forEach((element) => {
          localVarFormParams.append('tags', element as any)
        })
      }

      if (status !== undefined) {
        localVarFormParams.set('status', status as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Pet' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Name of pet that needs to be updated
     * @param {string} [status] Status of pet that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePetWithForm(
      petId: number,
      name?: string,
      status?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'petId' is not null or undefined
      if (petId === null || petId === undefined) {
        throw new RequiredError(
          'petId',
          'Required parameter petId was null or undefined when calling updatePetWithForm.',
        )
      }
      const localVarPath = `/pet/{petId}`.replace(
        `{${'petId'}}`,
        encodeURIComponent(String(petId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary uploads an image
     * @param {number} petId ID of pet to update
     * @param {Object} [body]
     * @param {string} [additionalMetadata] Additional Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      petId: number,
      body?: Object,
      additionalMetadata?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'petId' is not null or undefined
      if (petId === null || petId === undefined) {
        throw new RequiredError(
          'petId',
          'Required parameter petId was null or undefined when calling uploadFile.',
        )
      }
      const localVarPath = `/pet/{petId}/uploadImage`.replace(
        `{${'petId'}}`,
        encodeURIComponent(String(petId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication petstore_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('petstore_auth', [''])
            : configuration.accessToken
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue
      }

      if (additionalMetadata !== undefined) {
        localVarQueryParameter['additionalMetadata'] = additionalMetadata
      }

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PetApi - functional programming interface
 * @export
 */
export const PetApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add a new pet to the store
     * @summary Add a new pet to the store
     * @param {Pet} body Create a new pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Pet> {
      const localVarFetchArgs = PetApiFetchParamCreator(configuration).addPet(
        body,
        id,
        name,
        category,
        photoUrls,
        tags,
        status,
        options,
      )
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePet(
      petId: number,
      apiKey?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).deletePet(petId, apiKey, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {string} [status] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByStatus(
      status?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).findPetsByStatus(status, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} [tags] Tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByTags(
      tags?: Array<string>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).findPetsByTags(tags, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPetById(
      petId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Pet> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).getPetById(petId, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Update an existing pet by Id
     * @summary Update an existing pet
     * @param {Pet} body Update an existent pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Pet> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).updatePet(body, id, name, category, photoUrls, tags, status, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Name of pet that needs to be updated
     * @param {string} [status] Status of pet that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePetWithForm(
      petId: number,
      name?: string,
      status?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).updatePetWithForm(petId, name, status, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary uploads an image
     * @param {number} petId ID of pet to update
     * @param {Object} [body]
     * @param {string} [additionalMetadata] Additional Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      petId: number,
      body?: Object,
      additionalMetadata?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = PetApiFetchParamCreator(
        configuration,
      ).uploadFile(petId, body, additionalMetadata, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * PetApi - factory interface
 * @export
 */
export const PetApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Add a new pet to the store
     * @summary Add a new pet to the store
     * @param {Pet} body Create a new pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options?: any,
    ) {
      return PetApiFp(configuration).addPet(
        body,
        id,
        name,
        category,
        photoUrls,
        tags,
        status,
        options,
      )(fetch, basePath)
    },
    /**
     *
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePet(petId: number, apiKey?: string, options?: any) {
      return PetApiFp(configuration).deletePet(
        petId,
        apiKey,
        options,
      )(fetch, basePath)
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {string} [status] Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByStatus(status?: string, options?: any) {
      return PetApiFp(configuration).findPetsByStatus(status, options)(
        fetch,
        basePath,
      )
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} [tags] Tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findPetsByTags(tags?: Array<string>, options?: any) {
      return PetApiFp(configuration).findPetsByTags(tags, options)(
        fetch,
        basePath,
      )
    },
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPetById(petId: number, options?: any) {
      return PetApiFp(configuration).getPetById(petId, options)(fetch, basePath)
    },
    /**
     * Update an existing pet by Id
     * @summary Update an existing pet
     * @param {Pet} body Update an existent pet in the store
     * @param {number} id
     * @param {string} name
     * @param {Category} category
     * @param {Array<string>} photoUrls
     * @param {Array<Tag>} tags
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePet(
      body: Pet,
      id: number,
      name: string,
      category: Category,
      photoUrls: Array<string>,
      tags: Array<Tag>,
      status: string,
      options?: any,
    ) {
      return PetApiFp(configuration).updatePet(
        body,
        id,
        name,
        category,
        photoUrls,
        tags,
        status,
        options,
      )(fetch, basePath)
    },
    /**
     *
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Name of pet that needs to be updated
     * @param {string} [status] Status of pet that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePetWithForm(
      petId: number,
      name?: string,
      status?: string,
      options?: any,
    ) {
      return PetApiFp(configuration).updatePetWithForm(
        petId,
        name,
        status,
        options,
      )(fetch, basePath)
    },
    /**
     *
     * @summary uploads an image
     * @param {number} petId ID of pet to update
     * @param {Object} [body]
     * @param {string} [additionalMetadata] Additional Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      petId: number,
      body?: Object,
      additionalMetadata?: string,
      options?: any,
    ) {
      return PetApiFp(configuration).uploadFile(
        petId,
        body,
        additionalMetadata,
        options,
      )(fetch, basePath)
    },
  }
}

/**
 * PetApi - object-oriented interface
 * @export
 * @class PetApi
 * @extends {BaseAPI}
 */
export class PetApi extends BaseAPI {
  /**
   * Add a new pet to the store
   * @summary Add a new pet to the store
   * @param {Pet} body Create a new pet in the store
   * @param {number} id
   * @param {string} name
   * @param {Category} category
   * @param {Array<string>} photoUrls
   * @param {Array<Tag>} tags
   * @param {string} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public addPet(
    body: Pet,
    id: number,
    name: string,
    category: Category,
    photoUrls: Array<string>,
    tags: Array<Tag>,
    status: string,
    options?: any,
  ) {
    return PetApiFp(this.configuration).addPet(
      body,
      id,
      name,
      category,
      photoUrls,
      tags,
      status,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Deletes a pet
   * @param {number} petId Pet id to delete
   * @param {string} [apiKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public deletePet(petId: number, apiKey?: string, options?: any) {
    return PetApiFp(this.configuration).deletePet(
      petId,
      apiKey,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Multiple status values can be provided with comma separated strings
   * @summary Finds Pets by status
   * @param {string} [status] Status values that need to be considered for filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public findPetsByStatus(status?: string, options?: any) {
    return PetApiFp(this.configuration).findPetsByStatus(status, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
   * @summary Finds Pets by tags
   * @param {Array<string>} [tags] Tags to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public findPetsByTags(tags?: Array<string>, options?: any) {
    return PetApiFp(this.configuration).findPetsByTags(tags, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Returns a single pet
   * @summary Find pet by ID
   * @param {number} petId ID of pet to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public getPetById(petId: number, options?: any) {
    return PetApiFp(this.configuration).getPetById(petId, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Update an existing pet by Id
   * @summary Update an existing pet
   * @param {Pet} body Update an existent pet in the store
   * @param {number} id
   * @param {string} name
   * @param {Category} category
   * @param {Array<string>} photoUrls
   * @param {Array<Tag>} tags
   * @param {string} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public updatePet(
    body: Pet,
    id: number,
    name: string,
    category: Category,
    photoUrls: Array<string>,
    tags: Array<Tag>,
    status: string,
    options?: any,
  ) {
    return PetApiFp(this.configuration).updatePet(
      body,
      id,
      name,
      category,
      photoUrls,
      tags,
      status,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Updates a pet in the store with form data
   * @param {number} petId ID of pet that needs to be updated
   * @param {string} [name] Name of pet that needs to be updated
   * @param {string} [status] Status of pet that needs to be updated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public updatePetWithForm(
    petId: number,
    name?: string,
    status?: string,
    options?: any,
  ) {
    return PetApiFp(this.configuration).updatePetWithForm(
      petId,
      name,
      status,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary uploads an image
   * @param {number} petId ID of pet to update
   * @param {Object} [body]
   * @param {string} [additionalMetadata] Additional Metadata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PetApi
   */
  public uploadFile(
    petId: number,
    body?: Object,
    additionalMetadata?: string,
    options?: any,
  ) {
    return PetApiFp(this.configuration).uploadFile(
      petId,
      body,
      additionalMetadata,
      options,
    )(this.fetch, this.basePath)
  }
}
/**
 * StoreApi - fetch parameter creator
 * @export
 */
export const StoreApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param {number} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrder(orderId: number, options: any = {}): FetchArgs {
      // verify required parameter 'orderId' is not null or undefined
      if (orderId === null || orderId === undefined) {
        throw new RequiredError(
          'orderId',
          'Required parameter orderId was null or undefined when calling deleteOrder.',
        )
      }
      const localVarPath = `/store/order/{orderId}`.replace(
        `{${'orderId'}}`,
        encodeURIComponent(String(orderId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventory(options: any = {}): FetchArgs {
      const localVarPath = `/store/inventory`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication api_key required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('api_key')
            : configuration.apiKey
        localVarHeaderParameter['api_key'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of order that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderById(orderId: number, options: any = {}): FetchArgs {
      // verify required parameter 'orderId' is not null or undefined
      if (orderId === null || orderId === undefined) {
        throw new RequiredError(
          'orderId',
          'Required parameter orderId was null or undefined when calling getOrderById.',
        )
      }
      const localVarPath = `/store/order/{orderId}`.replace(
        `{${'orderId'}}`,
        encodeURIComponent(String(orderId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Place a new order in the store
     * @summary Place an order for a pet
     * @param {Order} [body]
     * @param {number} [id]
     * @param {number} [petId]
     * @param {number} [quantity]
     * @param {Date} [shipDate]
     * @param {string} [status]
     * @param {boolean} [complete]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placeOrder(
      body?: Order,
      id?: number,
      petId?: number,
      quantity?: number,
      shipDate?: Date,
      status?: string,
      complete?: boolean,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/store/order`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      if (id !== undefined) {
        localVarFormParams.set('id', id as any)
      }

      if (petId !== undefined) {
        localVarFormParams.set('petId', petId as any)
      }

      if (quantity !== undefined) {
        localVarFormParams.set('quantity', quantity as any)
      }

      if (shipDate !== undefined) {
        localVarFormParams.set('shipDate', shipDate as any)
      }

      if (status !== undefined) {
        localVarFormParams.set('status', status as any)
      }

      if (complete !== undefined) {
        localVarFormParams.set('complete', complete as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'Order' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function (configuration?: Configuration) {
  return {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param {number} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrder(
      orderId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).deleteOrder(orderId, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventory(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<{ [key: string]: number }> {
      const localVarFetchArgs =
        StoreApiFetchParamCreator(configuration).getInventory(options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of order that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderById(
      orderId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).getOrderById(orderId, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Place a new order in the store
     * @summary Place an order for a pet
     * @param {Order} [body]
     * @param {number} [id]
     * @param {number} [petId]
     * @param {number} [quantity]
     * @param {Date} [shipDate]
     * @param {string} [status]
     * @param {boolean} [complete]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placeOrder(
      body?: Order,
      id?: number,
      petId?: number,
      quantity?: number,
      shipDate?: Date,
      status?: string,
      complete?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
      const localVarFetchArgs = StoreApiFetchParamCreator(
        configuration,
      ).placeOrder(
        body,
        id,
        petId,
        quantity,
        shipDate,
        status,
        complete,
        options,
      )
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param {number} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrder(orderId: number, options?: any) {
      return StoreApiFp(configuration).deleteOrder(orderId, options)(
        fetch,
        basePath,
      )
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventory(options?: any) {
      return StoreApiFp(configuration).getInventory(options)(fetch, basePath)
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of order that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderById(orderId: number, options?: any) {
      return StoreApiFp(configuration).getOrderById(orderId, options)(
        fetch,
        basePath,
      )
    },
    /**
     * Place a new order in the store
     * @summary Place an order for a pet
     * @param {Order} [body]
     * @param {number} [id]
     * @param {number} [petId]
     * @param {number} [quantity]
     * @param {Date} [shipDate]
     * @param {string} [status]
     * @param {boolean} [complete]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placeOrder(
      body?: Order,
      id?: number,
      petId?: number,
      quantity?: number,
      shipDate?: Date,
      status?: string,
      complete?: boolean,
      options?: any,
    ) {
      return StoreApiFp(configuration).placeOrder(
        body,
        id,
        petId,
        quantity,
        shipDate,
        status,
        complete,
        options,
      )(fetch, basePath)
    },
  }
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
  /**
   * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
   * @summary Delete purchase order by ID
   * @param {number} orderId ID of the order that needs to be deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public deleteOrder(orderId: number, options?: any) {
    return StoreApiFp(this.configuration).deleteOrder(orderId, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Returns a map of status codes to quantities
   * @summary Returns pet inventories by status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public getInventory(options?: any) {
    return StoreApiFp(this.configuration).getInventory(options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
   * @summary Find purchase order by ID
   * @param {number} orderId ID of order that needs to be fetched
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public getOrderById(orderId: number, options?: any) {
    return StoreApiFp(this.configuration).getOrderById(orderId, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Place a new order in the store
   * @summary Place an order for a pet
   * @param {Order} [body]
   * @param {number} [id]
   * @param {number} [petId]
   * @param {number} [quantity]
   * @param {Date} [shipDate]
   * @param {string} [status]
   * @param {boolean} [complete]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StoreApi
   */
  public placeOrder(
    body?: Order,
    id?: number,
    petId?: number,
    quantity?: number,
    shipDate?: Date,
    status?: string,
    complete?: boolean,
    options?: any,
  ) {
    return StoreApiFp(this.configuration).placeOrder(
      body,
      id,
      petId,
      quantity,
      shipDate,
      status,
      complete,
      options,
    )(this.fetch, this.basePath)
  }
}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param {User} [body] Created user object
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      if (id !== undefined) {
        localVarFormParams.set('id', id as any)
      }

      if (username !== undefined) {
        localVarFormParams.set('username', username as any)
      }

      if (firstName !== undefined) {
        localVarFormParams.set('firstName', firstName as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.set('lastName', lastName as any)
      }

      if (email !== undefined) {
        localVarFormParams.set('email', email as any)
      }

      if (password !== undefined) {
        localVarFormParams.set('password', password as any)
      }

      if (phone !== undefined) {
        localVarFormParams.set('phone', phone as any)
      }

      if (userStatus !== undefined) {
        localVarFormParams.set('userStatus', userStatus as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'User' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates list of users with given input array
     * @summary Creates list of users with given input array
     * @param {Array<User>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUsersWithListInput(body?: Array<User>, options: any = {}): FetchArgs {
      const localVarPath = `/user/createWithList`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      const needsSerialization =
        <any>'Array&lt;User&gt;' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling deleteUser.',
        )
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling getUserByName.',
        )
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Logs user into the system
     * @param {string} [username] The user name for login
     * @param {string} [password] The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      username?: string,
      password?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/user/login`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options: any = {}): FetchArgs {
      const localVarPath = `/user/logout`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param {string} username name that need to be deleted
     * @param {User} [body] Update an existent user in the store
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      username: string,
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling updateUser.',
        )
      }
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      if (id !== undefined) {
        localVarFormParams.set('id', id as any)
      }

      if (username !== undefined) {
        localVarFormParams.set('username', username as any)
      }

      if (firstName !== undefined) {
        localVarFormParams.set('firstName', firstName as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.set('lastName', lastName as any)
      }

      if (email !== undefined) {
        localVarFormParams.set('email', email as any)
      }

      if (password !== undefined) {
        localVarFormParams.set('password', password as any)
      }

      if (phone !== undefined) {
        localVarFormParams.set('phone', phone as any)
      }

      if (userStatus !== undefined) {
        localVarFormParams.set('userStatus', userStatus as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      )
      localVarRequestOptions.body = localVarFormParams.toString()
      const needsSerialization =
        <any>'User' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param {User} [body] Created user object
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).createUser(
        body,
        id,
        username,
        firstName,
        lastName,
        email,
        password,
        phone,
        userStatus,
        options,
      )
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Creates list of users with given input array
     * @summary Creates list of users with given input array
     * @param {Array<User>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUsersWithListInput(
      body?: Array<User>,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).createUsersWithListInput(body, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      username: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).deleteUser(username, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName(
      username: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).getUserByName(username, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Logs user into the system
     * @param {string} [username] The user name for login
     * @param {string} [password] The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      username?: string,
      password?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).loginUser(username, password, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        UserApiFetchParamCreator(configuration).logoutUser(options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param {string} username name that need to be deleted
     * @param {User} [body] Update an existent user in the store
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      username: string,
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration,
      ).updateUser(
        username,
        body,
        id,
        username,
        firstName,
        lastName,
        email,
        password,
        phone,
        userStatus,
        options,
      )
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param {User} [body] Created user object
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options?: any,
    ) {
      return UserApiFp(configuration).createUser(
        body,
        id,
        username,
        firstName,
        lastName,
        email,
        password,
        phone,
        userStatus,
        options,
      )(fetch, basePath)
    },
    /**
     * Creates list of users with given input array
     * @summary Creates list of users with given input array
     * @param {Array<User>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUsersWithListInput(body?: Array<User>, options?: any) {
      return UserApiFp(configuration).createUsersWithListInput(body, options)(
        fetch,
        basePath,
      )
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any) {
      return UserApiFp(configuration).deleteUser(username, options)(
        fetch,
        basePath,
      )
    },
    /**
     *
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName(username: string, options?: any) {
      return UserApiFp(configuration).getUserByName(username, options)(
        fetch,
        basePath,
      )
    },
    /**
     *
     * @summary Logs user into the system
     * @param {string} [username] The user name for login
     * @param {string} [password] The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(username?: string, password?: string, options?: any) {
      return UserApiFp(configuration).loginUser(
        username,
        password,
        options,
      )(fetch, basePath)
    },
    /**
     *
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUser(options?: any) {
      return UserApiFp(configuration).logoutUser(options)(fetch, basePath)
    },
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param {string} username name that need to be deleted
     * @param {User} [body] Update an existent user in the store
     * @param {number} [id]
     * @param {string} [username]
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {string} [email]
     * @param {string} [password]
     * @param {string} [phone]
     * @param {number} [userStatus]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      username: string,
      body?: User,
      id?: number,
      username?: string,
      firstName?: string,
      lastName?: string,
      email?: string,
      password?: string,
      phone?: string,
      userStatus?: number,
      options?: any,
    ) {
      return UserApiFp(configuration).updateUser(
        username,
        body,
        id,
        username,
        firstName,
        lastName,
        email,
        password,
        phone,
        userStatus,
        options,
      )(fetch, basePath)
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * This can only be done by the logged in user.
   * @summary Create user
   * @param {User} [body] Created user object
   * @param {number} [id]
   * @param {string} [username]
   * @param {string} [firstName]
   * @param {string} [lastName]
   * @param {string} [email]
   * @param {string} [password]
   * @param {string} [phone]
   * @param {number} [userStatus]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createUser(
    body?: User,
    id?: number,
    username?: string,
    firstName?: string,
    lastName?: string,
    email?: string,
    password?: string,
    phone?: string,
    userStatus?: number,
    options?: any,
  ) {
    return UserApiFp(this.configuration).createUser(
      body,
      id,
      username,
      firstName,
      lastName,
      email,
      password,
      phone,
      userStatus,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Creates list of users with given input array
   * @summary Creates list of users with given input array
   * @param {Array<User>} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createUsersWithListInput(body?: Array<User>, options?: any) {
    return UserApiFp(this.configuration).createUsersWithListInput(
      body,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * This can only be done by the logged in user.
   * @summary Delete user
   * @param {string} username The name that needs to be deleted
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUser(username: string, options?: any) {
    return UserApiFp(this.configuration).deleteUser(username, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   *
   * @summary Get user by user name
   * @param {string} username The name that needs to be fetched. Use user1 for testing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserByName(username: string, options?: any) {
    return UserApiFp(this.configuration).getUserByName(username, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   *
   * @summary Logs user into the system
   * @param {string} [username] The user name for login
   * @param {string} [password] The password for login in clear text
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public loginUser(username?: string, password?: string, options?: any) {
    return UserApiFp(this.configuration).loginUser(
      username,
      password,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Logs out current logged in user session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public logoutUser(options?: any) {
    return UserApiFp(this.configuration).logoutUser(options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * This can only be done by the logged in user.
   * @summary Update user
   * @param {string} username name that need to be deleted
   * @param {User} [body] Update an existent user in the store
   * @param {number} [id]
   * @param {string} [username]
   * @param {string} [firstName]
   * @param {string} [lastName]
   * @param {string} [email]
   * @param {string} [password]
   * @param {string} [phone]
   * @param {number} [userStatus]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateUser(
    username: string,
    body?: User,
    id?: number,
    username?: string,
    firstName?: string,
    lastName?: string,
    email?: string,
    password?: string,
    phone?: string,
    userStatus?: number,
    options?: any,
  ) {
    return UserApiFp(this.configuration).updateUser(
      username,
      body,
      id,
      username,
      firstName,
      lastName,
      email,
      password,
      phone,
      userStatus,
      options,
    )(this.fetch, this.basePath)
  }
}
